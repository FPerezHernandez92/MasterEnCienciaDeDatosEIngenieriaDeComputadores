par3d(windowRect = 50 + c( 0, 0, width, width ) )
rgl.bg(color = bg )
}
rgl.clear(type = c("shapes", "bboxdeco"))
rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
# x, y, z : numeric vectors corresponding to
#  the coordinates of points
# axis.col : axis colors
# xlab, ylab, zlab: axis labels
# show.plane : add axis planes
# show.bbox : add the bounding box decoration
# bbox.col: the bounding box colors. The first color is the
# the background color; the second color is the color of tick marks
rgl_add_axes <- function(x, y, z, axis.col = "grey",
xlab = "", ylab="", zlab="", show.plane = TRUE,
show.bbox = FALSE, bbox.col = c("#333377","black"))
{
lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
# Add axes
xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
# Add a point at the end of each axes to specify the direction
axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0),
c(0, 0, zlim[2]))
rgl.points(axes, color = axis.col, size = 3)
# Add axis labels
rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
adj = c(0.5, -0.8), size = 2)
# Add plane
if(show.plane)
xlim <- xlim/1.1; zlim <- zlim /1.1
rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
# Add bounding box decoration
library(rgl)
#' @param new.device a logical value. If TRUE, creates a new device
#' @param bg the background color of the device
#' @param width the width of the device
rgl_init <- function(new.device = FALSE, bg = "white", width = 640) {
if( new.device | rgl.cur() == 0 ) {
rgl.open()
par3d(windowRect = 50 + c( 0, 0, width, width ) )
rgl.bg(color = bg )
}
rgl.clear(type = c("shapes", "bboxdeco"))
rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
# x, y, z : numeric vectors corresponding to
#  the coordinates of points
# axis.col : axis colors
# xlab, ylab, zlab: axis labels
# show.plane : add axis planes
# show.bbox : add the bounding box decoration
# bbox.col: the bounding box colors. The first color is the
# the background color; the second color is the color of tick marks
rgl_add_axes <- function(x, y, z, axis.col = "grey",
xlab = "", ylab="", zlab="", show.plane = TRUE,
show.bbox = FALSE, bbox.col = c("#333377","black"))
{
lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
# Add axes
xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
# Add a point at the end of each axes to specify the direction
axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0),
c(0, 0, zlim[2]))
rgl.points(axes, color = axis.col, size = 3)
# Add axis labels
rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
adj = c(0.5, -0.8), size = 2)
# Add plane
if(show.plane)
xlim <- xlim/1.1; zlim <- zlim /1.1
rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
# Add bounding box decoration
if(show.bbox){
rgl.bbox(color=c(bbox.col[1],bbox.col[2]), alpha = 0.5,
emission=bbox.col[1], specular=bbox.col[1], shininess=5,
xlen = 3, ylen = 3, zlen = 3)
}
}
# Ejemplo que ilustra el modelo de clasificación usando una variable
ç
library(rgl)
#' @param new.device a logical value. If TRUE, creates a new device
#' @param bg the background color of the device
#' @param width the width of the device
rgl_init <- function(new.device = FALSE, bg = "white", width = 640) {
if( new.device | rgl.cur() == 0 ) {
rgl.open()
par3d(windowRect = 50 + c( 0, 0, width, width ) )
rgl.bg(color = bg )
}
rgl.clear(type = c("shapes", "bboxdeco"))
rgl.viewpoint(theta = 15, phi = 20, zoom = 0.7)
}
# x, y, z : numeric vectors corresponding to
#  the coordinates of points
# axis.col : axis colors
# xlab, ylab, zlab: axis labels
# show.plane : add axis planes
# show.bbox : add the bounding box decoration
# bbox.col: the bounding box colors. The first color is the
# the background color; the second color is the color of tick marks
rgl_add_axes <- function(x, y, z, axis.col = "grey",
xlab = "", ylab="", zlab="", show.plane = TRUE,
show.bbox = FALSE, bbox.col = c("#333377","black"))
{
lim <- function(x){c(-max(abs(x)), max(abs(x))) * 1.1}
# Add axes
xlim <- lim(x); ylim <- lim(y); zlim <- lim(z)
rgl.lines(xlim, c(0, 0), c(0, 0), color = axis.col)
rgl.lines(c(0, 0), ylim, c(0, 0), color = axis.col)
rgl.lines(c(0, 0), c(0, 0), zlim, color = axis.col)
# Add a point at the end of each axes to specify the direction
axes <- rbind(c(xlim[2], 0, 0), c(0, ylim[2], 0),
c(0, 0, zlim[2]))
rgl.points(axes, color = axis.col, size = 3)
# Add axis labels
rgl.texts(axes, text = c(xlab, ylab, zlab), color = axis.col,
adj = c(0.5, -0.8), size = 2)
# Add plane
if(show.plane)
xlim <- xlim/1.1; zlim <- zlim /1.1
rgl.quads( x = rep(xlim, each = 2), y = c(0, 0, 0, 0),
z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
# Add bounding box decoration
if(show.bbox){
rgl.bbox(color=c(bbox.col[1],bbox.col[2]), alpha = 0.5,
emission=bbox.col[1], specular=bbox.col[1], shininess=5,
xlen = 3, ylen = 3, zlen = 3)
}
}
# Ejemplo que ilustra el modelo de clasificación usando una variable
datos <-data.frame(y=as.numeric(as.numeric(iris$Species)),
x4=iris$Sepal.Width,
x1=iris$Sepal.Length,
x2=iris$Petal.Length,
x3=iris$Petal.Width)
library(splines)
model3 <- glm(y~ns(x2,16), data =datos)
b <- predict(model3, datos)
rb <- round(b)
x <- seq(1,7,0.01)
x <- rbind(x2=x,y=0)
x <-t(x)
x <-as.data.frame(x)
xy <- predict(model3, newdata = x)
rxy <-round(xy)
plot(datos$x2, datos$y, col = datos$y, xlab = "Longitud del Sépalo", ylab = "Tipo de Iris", title("Specie ~ ns(Petal.Length,16)"))
lines(x[,1],xy,col=ifelse(xy<=1.5, "black", ifelse(xy<=2.5, "red", "green")))
segments(datos$x2,datos$y,datos$x2,b, col=datos$y, lty=4)
abline(2.5,0,col="green")
abline(1.5,0,col="red")
# Ejemplo que ilustra el modelo de clasificación en base a 2 variables
model3 <- glm(y~ns(x2,16)+ns(x1,16), data =datos)
c <- predict(model3, newdata = datos)
plot(datos$x2,datos$x1,col=round(c),pch=0,
xlab = "Longitud del Sépalo", ylab = "Longitud del Pétalo", title("Specie ~ ns(Petal.Length,16)+ns(Sepal.Length,16)"))
points(datos$x2,datos$x1,col=datos$y,pch="x")
#### Ilustrar como se distribuye los espacios de clasificación
plantilla <-matrix(c(0,0,0),ncol=3)
for (p1 in seq(1,8,0.05))
for (p2 in seq(1,7,0.05))
plantilla <-rbind(plantilla, c(x1=p1,x2=p2,y=0))
plantilla <- as.data.frame(plantilla)
plantilla[,3] <- predict(model3, newdata = plantilla)
plot(datos$x2,datos$x1,col=round(c),pch=0,
xlab = "Longitud del Sépalo", ylab = "Longitud del Pétalo", title("Specie ~ ns(Petal.Length,16)+ns(Sepal.Length,16)"))
points(plantilla$x2,plantilla$x1,
col= ifelse(round(plantilla$y)<1, 0, ifelse(round(plantilla$y)>3, 0, round(plantilla$y) )),pch=20)
points(datos$x2,datos$x1,col=round(c),pch=0)
points(datos$x2,datos$x1,col=datos$y,pch="x")
# Ejemplo que ilustra el modelo de clasificación en base a 3 variables
model3 <- glm(y~ns(x2,16)+ns(x1,16)+ns(x3,16), data =datos)
c <- predict(model3, newdata = datos)
plantilla <-matrix(c(0,0,0,0),ncol=4)
for (p1 in seq(1,8,(8-1)/10))
for (p2 in seq(1,7,(7-1)/10))
for (p3 in seq(0, 2.5, 2.5/10 ))
plantilla <-rbind(plantilla, c(x1=p1,x2=p2,x3=p3,y=0))
plantilla <- as.data.frame(plantilla)
plantilla[,4] <- round(predict(model3, newdata = plantilla))
plantilla[,4] <- ifelse(plantilla[,4]<1,"white", ifelse(plantilla[,4]>3,"white",plantilla[,4]))
#saca la grafica en 3d
library(rgl)
rgl_init()
rgl.spheres(x=datos$x2, y=datos$x1, z=datos$x3, r=0.1, col=datos$y)
rgl_add_axes(x=datos$x2, y=datos$x1, z=datos$x3, show.bbox = T)
aspect3d(1,1,1)
#### Ilustra como se distribuyen los espacios de clasificación
rgl_init()
rgl.spheres(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], r=0.1, col=plantilla[,4])
#rgl_add_axes(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], show.bbox = T)
aspect3d(1,1,1)
plot3d(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], col=plantilla[,4])
rgl_init()
rgl.spheres(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], r=0.1, col=plantilla[,4])
rgl_add_axes(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], show.bbox = T)
aspect3d(1,1,1)
plot3d(x=plantilla[,1], y=plantilla[,2], z=plantilla[,3], col=plantilla[,4])
library(tree)
summary(iris)
# Construir un arbol que clasifica la especie en base al resto de variables
tree.iris = tree(Species~.,iris)
library(tree)
install.packages("tree")
summary(iris)
# Construir un arbol que clasifica la especie en base al resto de variables
tree.iris = tree(Species~.,iris)
library(tree)
summary(iris)
# Construir un arbol que clasifica la especie en base al resto de variables
tree.iris = tree(Species~.,iris)
summary(tree.iris)
plot(tree.iris)
text(tree.iris, pretty=0)
tree.iris
# Dividir en training y test
set.seed (2)
train=sample (1:nrow(iris), 100)
iris.test=iris [-train ,]
# Construyo el arbol sobre el conjunto de entrenamiento
tree.iris =tree(Species~. ,iris ,subset =train )
# Aplico el arbol sobre el conjunto de test
tree.pred =predict (tree.iris ,iris.test ,type ="class")
# Visualizo la matriz de confusion
table(tree.pred , iris.test[,5])
# Podar el arbol usando cv
set.seed (3)
cv.iris = cv.tree(tree.iris ,FUN=prune.misclass )
names(cv.iris )
cv.iris
# Pintamos el error
par(mfrow =c(1,2))
plot(cv.iris$size ,cv.iris$dev ,type="b")
plot(cv.iris$k ,cv.iris$dev ,type="b")
# Ahora podamos el arbol con prune.misclass
prune.iris =prune.misclass (tree.iris ,best =3)
par(mfrow =c(1,1))
plot(prune.iris)
text(prune.iris ,pretty =0)
# Como se comportara este arbol en su capacidad de prediccion
tree.pred=predict (prune.iris , iris.test ,type="class")
table(tree.pred ,iris.test[,5])
# Ahora podemos modificar el tamanio del arbol modificando best
prune.iris =prune.misclass (tree.iris ,best =4)
plot(prune.iris)
text(prune.iris ,pretty =0)
tree.pred=predict (prune.iris , iris.test ,type="class")
table(tree.pred ,iris.test[,5])
# Random Forest
library (randomForest)
set.seed (1)
bag.iris = randomForest(Species~., data=iris, subset=train)
bag.iris
yhat.bag = predict (bag.iris ,newdata =iris.test)
yhat.bag
# Construyo una funcion para calcular el acierto a partir del RandomForest
acierto <- function(bag.datos){
return (sum (sapply(1:length(bag.datos$y), function(x){
if (is.na(bag.datos$predicted[x])){
0
}
else if (as.numeric(bag.datos$y[x])==as.numeric(bag.datos$predicted[x])){
1
}
else{
0
}
}))/length(bag.datos$y))
}
resul = as.data.frame(cbind(predicted = yhat.bag, y=iris.test[,5]))
acierto(resul)
# Fijando el numero de arboles
bag.iris = randomForest(Species~.,data=iris ,subset =train , ntree=25)
bag.iris
acierto(bag.iris)
bag.func = randomForest(formula,data=datos,ntree=num_trees)
bag.func = randomForest(formula,data=datos,subset=train,ntree=num_trees)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
bag.func = randomForest(formula,data=datos,subset=train,ntree=num_trees)
acierto(bag.func)
}
Graphical_RF(iris,Species~.,100)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
}
Graphical_RF(iris,Species~.,100)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
}
Graphical_RF(iris,Species~.,100)
vec
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
vec
}
Graphical_RF(iris,Species~.,100)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
plot(1:num_trees,vec)
}
Graphical_RF(iris,Species~.,100)
lines()
lines(vec)
Graphical_RF <- function(datos, formula, num_trees){
# Definir aqui la funcion
vec <- sapply(1:num_trees, function(x){
bag.func = randomForest(formula,data=datos,subset=train,ntree=x)
acierto(bag.func)
})
plot(1:num_trees,vec)
lines(vec)
}
Graphical_RF(iris,Species~.,100)
summary(iris)
summary(Auto)
Auto
Autos
summary(Autos)
library(ISLR)
summary(Autos)
summary(Auto)
dim(Auto)
dim(iris)
set.seed (2)
train=sample (1:nrow(Auto), 300)
datos = Auto
Graphical_RF(datos,origin~.-name,100)
train=sample (1:nrow(iris), 100)
set.seed (2)
train=sample (1:nrow(iris), 100)
setwd("~/Dropbox/zMaster/zRStudio/Master-en-Ciencia-De-Datos-e-Ingeniería-de-Computadores/1 Introduccion a la Ciencia de Datos/5 Trabajo Final")
setwd("~/Dropbox/zMaster/zRStudio/Master-en-Ciencia-De-Datos-e-Ingeniería-de-Computadores/1 Introduccion a la Ciencia de Datos/3 Ejercicios regresion")
#FRANCISCO PÉREZ HERNÁNDEZ 20076629K
require(ISLR)
require(MASS)
Boston
fix(Boston)
help(Boston)
attach(Boston)
#Búsqueda de posibles relaciones
temp <- Boston
plotY <- function (x,y) {
plot(temp[,y]~temp[,x], xlab=paste(names(temp)[x]," X",x,sep=""), ylab=names(temp)[y])
}
par(mfrow=c(3,4))
x <- sapply(1:(dim(temp)[2]-1), plotY, dim(temp)[2])
par(mfrow=c(1,1))
#Si afinamos más
par(mfrow=c(3,3))
x <- sapply(c(1, 5, 6, 7, 8, 10, 11, 12, 13), plotY, dim(temp)[2])
par(mfrow=c(1,1))
#Donde se ve que las candidatas son rm y lstat
#Modelo lineal para lstat
fit1=lm(medv~lstat)
fit1
#Modelo para rm
fit2=lm(medv~rm)
fit2
#Visualización
summary(fit1)
par(mfrow=c(2,1))
plot(medv~lstat,Boston)
abline(fit1,col="red")
confint(fit1)
summary(fit2)
plot(medv~rm,Boston)
abline(fit2,col="blue")
par(mfrow=c(1,1))
confint(fit2)
#Cálculo manual de la raíz del ECM (RMSE)
sqrt(sum(fit1$residuals^2)/length(fit1$residuals))
#Predicción de nuevos datos
predict(fit1,data.frame(lstat=c(5,10,15)))
#Cálculo manual de la raiz del ECM (RMSE) para el conjunto de test
yprime=predict(fit1,data.frame(lstat=Boston$lstat))
#o directamente #yprime=predict(fit1,Boston)
sqrt(sum(abs(Boston$medv-yprime)^2)/length(yprime))
#Modelos lineales múltiples
fit3=lm(medv~lstat+age,data=Boston)
summary(fit3)
#Visualización de pares de variables por escala de grises
temp <- Boston
plot(temp[,-dim(temp)[2]],pch=16,col=gray(1-(temp[,dim(temp)[2]]/max(temp[,dim(temp)[2]]))))
fit4=lm(medv~lstat+rm,data=Boston)
summary(fit4)
fit5=lm(medv~.,data=Boston)
summary(fit5)
fit6=lm(medv~.-age-indus,data=Boston)
summary(fit6)
fit7=lm(medv~.-age-indus-chas-crim,data=Boston)
summary(fit7)
fit8=lm(medv~lstat*rm,Boston)
summary(fit8)
plot(medv~lstat)
points(lstat,fitted(fit8),col="green",pch=20)
fit9=lm(medv~I(lstat^2),Boston)
summary(fit9)
plot(medv~lstat)
points(lstat,fitted(fit9),col="red",pch=20)
fit9=lm(medv~lstat +I(lstat^2),Boston)
summary(fit9)
plot(medv~lstat)
points(lstat,fitted(fit9),col="red",pch=20)
fit10=lm(medv~poly(lstat,18))
summary(fit10)
points(lstat,fitted(fit10),col="blue",pch=20)
fit11=lm(medv~poly(lstat,5))
summary(fit11)
points(lstat,fitted(fit11),col="green",pch=20)
fitprueba=lm(medv~lstat +rm +I(lstat * rm) +I(lstat^2) +I(lstat^2 * rm),Boston)
summary(fitprueba)
plot(medv~lstat)
points(lstat,fitted(fitprueba),col="red",pch=20)
#Predicción sobre nuevos datos
yprime=predict(fit8,Boston)
sqrt(sum(abs(Boston$medv-yprime)^2)/length(yprime))
xtra <- read.csv("california.dat", comment.char = "@")
#Asignación manual
names(xtra) <- c("Longitude", "Latitude", "HousingMedianAge",
"TotalRooms", "TotalBedrooms", "Population", "Households", "MedianIncome", "MedianHouseValue")
#Asignación automática, facilita el acceso a los campos
n <- length(names(xtra)) - 1
names(xtra)[1:n] <- paste ("X", 1:n, sep="")
names(xtra)[n+1] <- "Y"
help(xtra)
??xtra
#Como no hay mucha información sobre las variables y el tipo
#de problema voy a realizar la previsualización de todas las
#variables entre si
temp <- xtra
plotY <- function (x,y) {
plot(temp[,y]~temp[,x], xlab=paste(names(temp)[x]," X",x,sep=""), ylab=names(temp)[y])
}
par(mfrow=c(2,4))
x <- sapply(1:(dim(temp)[2]-1), plotY, dim(temp)[2])
par(mfrow=c(1,1))
#Por lo que podemos ver en las gráficas, la variable que podría
#tener interés para nosotros podría ser X6, y quizás X2 y X8
#Modelo lineal para X6
fit1X6=lm(xtra$Y~xtra$X6)
fit1X6
#Modelo para X2
fit2X2=lm(xtra$Y~xtra$X2)
fit2X2
#Modelo para X8
fit3X8=lm(xtra$Y~xtra$X8)
fit3X8
#Visualización
summary(fit1X6) #0.0005582
par(mfrow=c(3,1))
plot(xtra$Y~xtra$X6)
abline(fit1X6,col="red")
confint(fit1X6)
summary(fit2X2) #0.02074
plot(xtra$Y~xtra$X2)
abline(fit2X2,col="blue")
confint(fit2X2)
summary(fit3X8) #0.4734
plot(xtra$Y~xtra$X8)
abline(fit3X8,col="green")
confint(fit3X8)
par(mfrow=c(1,1))
#Como hemos visto ha resultado que todas las variables son
#representativas pero la que más nos ayuda es X8 ya que tenemos
#un R^2 de 0.4734
sqrt(sum(fit1X6$residuals^2)/length(fit1X6$residuals))
#Cálculo manual de la raíz del ECM (RMSE)
#Modelos lineales múltiples
fit4X6X2=lm(xtra$Y~xtra$X6+xtra$X2)
summary(fit4X6X2) #0.02234
fit5X6X8=lm(xtra$Y~xtra$X6+xtra$X8)
summary(fit5X6X8) #0.4742
fit6X2X8=lm(xtra$Y~xtra$X2+xtra$X8)
summary(fit6X2X8) #0.4814
fit7X2X6X8=lm(xtra$Y~xtra$X2+xtra$X6+xtra$X8)
summary(fit7X2X6X8) #0.4828
#Por lo que vemos que de momento el modelo que mejor se ajusta es
#la unión de X2,X6 y X8
fit8Todos=lm(Y~.,data=xtra)
summary(fit8Todos) #0.637
#Podemos ver como con todas las variables se consigue el mejor
#ajuste hasta el momento y no tenemos indicio de quitar ninguna
#variable
#CONCLUSIONES:
#El mejor modelo actual es con todas las variables, con lo que obtenemos que
#podemos explicar un 63,7% del problema con este modelo
